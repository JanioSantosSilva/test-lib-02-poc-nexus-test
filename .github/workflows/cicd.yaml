
name: CI/CD Workflow

on:
  push

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2
      with:
        persist-credentials: false

    - name: Generate SSH key
      run: |
        # Gerar a chave SSH
        mkdir -p ~/.ssh
        ssh-keygen -t rsa -b 4096 -C "your_email@example.com" -f ~/.ssh/id_rsa -N ""
        
        # Adicionar a chave pública ao arquivo known_hosts para evitar prompt de verificação
        ssh-keyscan github.com >> ~/.ssh/known_hosts

    - name: The migration
      id: migrate
      run: |
        # Configuração do nome e email do Git
        git config --global user.name "JanioSantosSilva"
        git config --global user.email "jose.j.santos.silva@avanade.com"
        
        # Clonar o repositório via SSH
        git clone git@github.com:JanioSantosSilva/docker-image.git repo-teste
        cd repo-teste

        # Criação ou verificação de branch
        git checkout -b feat || git checkout feat
        
        # Adicionar o repositório remoto via SSH
        git remote add starteam git@github.com:JanioSantosSilva/nuget-package.git

        # Validação de remotos
        git remote -v

        # Modificação de arquivo e commit
        echo "Minha alteração adicional via echo" >> mensagem.txt
        git add .
        git commit -m "Migrando repositório Github"

        # Push para o repositório remoto via SSH
        git push --force starteam feat

#jobs:
#  build:
#    runs-on: ubuntu-latest
#    permissions: 
#      contents: write
#
#    steps:
#    - name: Checkout repository
#      uses: actions/checkout@v2
#      with:
#        persist-credentials: false
#
#    - name: Set up GitHub token
#      env:
#        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#      run: |
#        git config --global url."https://${GH_TOKEN}@github.com/".insteadOf "https://github.com/"
#
#    - name: The migration
#      id: migrate
#      run: |
#        # Clone o repositório de origem
#        git clone "https://${{ secrets.GITHUB_TOKEN }}@github.com/JanioSantosSilva/docker-image.git" repo-teste
#        cd repo-teste
#
#        # Criação ou verificação de branch
#        git checkout -b feat || git checkout feat
#
#        git remote -v
#        
#        # Configuração do nome e email do Git
#        git config --global user.name "JanioSantosSilva"
#        git config --global user.email "jose.j.santos.silva@avanade.com"
#
#        # Adiciona o remoto para o novo repositório
#        git remote add starteam https://${{ secrets.GITHUB_TOKEN }}@github.com/JanioSantosSilva/nuget-package.git
#        
#        # Validação de remotos
#        git remote -v
#
#        # Modificação de arquivo e commit
#        echo "Minha alteração adicional via echo" >> mensagem.txt
#        git add .
#        git status
#        git commit -m "Migrando repositório Github"
#
#        # Push para o repositório remoto
#        git push --force starteam feat
#
#  # Configurações de usuário
#  #git config --global user.name "JanioSantosSilva"
#  #git config --global user.email "jose.j.santos.silva@avanade.com"

 #git remote add starteam https://${{ secrets.GITHUB_TOKEN }}@github.com/JanioSantosSilva/nuget-package.git
  #export GIT_TRACE=1
  #export GIT_CURL_VERBOSE=1
      
  #- name: Get properties
  #  id: checar_nome
  #  env:
  #    REPO_NAME: ${{ github.repository }}
  #  run: |
  #    REPO_NAME=$(echo ${{ github.repository }} | cut -d'/' -f2 | cut -d'-' -f4-)
  #  
  #    echo "Nome do repositório: $REPO_NAME"
  #    
  #    NOME_ENCONTRADO=$(echo "$REPO_NAME" | tr '-' '\n' | grep -E '^[a-zA-Z0-9]{4}$' || echo "$REPO_NAME" | grep -o 'EINT[^/]*')
  #    
  #    if [[ -n "$NOME_ENCONTRADO" ]]; then
  #      DIST_PROPERTIES=($(find . -name "test*.properties" -exec grep -h '^dist' {} +))
  #        echo "Todas as propriedades dist foram armazenadas no array:"
  #        printf "%s\n" "${DIST_PROPERTIES[@]}"
  #        for property in "${DIST_PROPERTIES[@]}"; do
  #          caminho=$(echo "$property" | sed 's/.*="\([^"]*\)".*/\1/')
  #          echo "paths: $caminho"
  #            properties_file=$(find . -name "jar*.properties")
  #            if [[ -n "$properties_file" ]]; then
  #               sed -i "s|^dist.*|dist.newvalue=$caminho|" "$properties_file"
  #               echo "Updated properties file: $properties_file"
  #               echo "New value set for dist: dist.newvalue=$caminho"
  #            else
  #              echo "Arquivo other.properties não encontrado."
  #            fi
  #        done
  #    else
  #       echo "Nenhum nome de centro de custo encontrado."
  #    fi

  #- name: Upload arquivos para Nexus
    #  run: |
    #    commitID=$(git rev-parse --short HEAD)  
    #    jarName="validate.jar" 
    #    jarNameWithCommit="${jarName%.jar}-${commitID}.jar" 
    #    echo "Fazendo upload do arquivo JAR antes do for: $jarNameWithCommit"
    #    for dist in $(cat dist.properties); do
    #      echo "Fazendo upload do arquivo JAR: $jarNameWithCommit"
    #    done
 #
    #- name: The migration
    #  id: migrate
    #  env:
    #  BB_REPO_URL: https://${{ vars.MIGRATION_BB_USER }}:${{ secrets.MIGRATION_BB_PASSWORD }}@bitbucket.bradesco.com.br:8443/scm/${{ steps.inputs.outputs.PROJECT_KEY }}/${{ steps.inputs.outputs.BITBUCKET_REPOSITORY }}.git
    #  MIGRATION_SOURCE: ${{ inputs.migration-source }}
    #  STARTEAM_URL_BASE: ${{ vars.MIGRATION_STARTEAM }}
    #  run: |
    #  echo "::group::Migration log"
    #  if [[ -n "${MIGRATION_SOURCE}" ]]; then
    #    printf "\e[0;33m%s\e[0m\n" "Adding remote for GitLab with URL ${MIGRATION_SOURCE}"
    #    git remote add bitbucket "${MIGRATION_SOURCE}"
    #    git config credential."${MIGRATION_SOURCE}".username oauth
    #    git config credential."${MIGRATION_SOURCE}".password '${{ vars.MIGRATION_GL_TOKEN }}'
    #  elif [[ -n "${STARTEAM_URL_BASE}" ]]; then
    #    printf "\e[0;33m%s\e[0m\n" "Adding remote for StarTeam with URL ${STARTEAM_URL_BASE}"
    #    URL=$(curl -u "${{ vars.G_NEXUS_SYS_USER }}:${{ secrets.G_PASSWORD_SYS_NEXUS }}" \
    #    -X GET "${{ vars.API_REPOSITORY_BASE }}/v1/search/assets?keyword=starteam%2Fclient%2FSt-CPC-17_3SP3-java.tar.gz&group=/starteam%2Fclient" \
    #    -H "Accept: application/json" -k | grep -i 'downloadUrl' | head -n 1 | cut -d '"' -f4)
    #    wget -O "St-CPC-17_3SP3-java.tar.gz" $URL --http-user=${{ vars.G_NEXUS_SYS_USER }} --http-password=${{ secrets.G_PASSWORD_SYS_NEXUS }} --no-check-certificate
    #    tar -xzf St-CPC-17_3SP3-java.tar.gz
    #    cd starteam-en-17.0.3-java
    #    cd bin
    #    ./setup
    #    sh ./git-remote-starteam-setup.sh
    #    export PATH=$PATH:"${{github.workspace}}/starteam-en-17.0.3-java/lib"
    #    git remote add bitbucket "${STARTEAM_URL_BASE}"
    #  elif [[ -n "${BB_REPO_URL}" ]]; then
    #    printf "\e[0;33m%s\e[0m\n" "Adding remote for Bitbucket with URL ${BB_REPO_URL}"
    #    git remote add bitbucket "${BB_REPO_URL}"
    #  fi
    #
    #  printf "\e[0;33m%s\e[0m\n" "Fetching from bitbucket remote"
    #  GIT_SSL_NO_VERIFY=1 git fetch bitbucket
    #
    #  # Undo last commit (the one that copied the template) and recommit only the workflow files
    #  git reset HEAD^1
    #  git checkout .
    #  git clean -f .
    #  git commit -m 'Configurado template de workflow [skip ci]'
    #
    #  # Disable exit-on-error
    #  set +e
    #
    #  # Rebase to keep commits from both repos (the ones from github will be after the one from bitbucket)
    #  printf "\e[0;33m%s\e[0m\n" "Pulling branch ${{ inputs.source-default-branch }} from bitbucket and rebasing onto $(git rev-parse --abbrev-ref HEAD)..."
    #  GIT_SSL_NO_VERIFY=1 git pull bitbucket ${{ inputs.source-default-branch }} --rebase
    #
    #  if (( $? != 0 )); then
    #    printf "\e[0;33m%s\e[0m\n" "Resolving rebase conflict..."
    #    git restore --ours .
    #    git add .
    #    git rebase --continue
    #  fi
    #
    #  # Rename Bitbucket's branch named as the target with -backup suffix, if exists and is different
    #  if [[ "${{ inputs.source-default-branch }}" != "${{ inputs.target-default-branch }}" ]]; then
    #    if git show-ref --verify --quiet refs/remotes/bitbucket/${{ inputs.target-default-branch }}; then
    #    printf "\e[0;33m%s\e[0m\n" "Renaming Bitbucket's ${{ inputs.target-default-branch }} branch to ${{ format('{0}-backup', inputs.target-default-branch) }}"
    #    git branch --track ${{ format('{0}-backup', inputs.target-default-branch) }} bitbucket/${{ inputs.target-default-branch }}
    #    git push origin ${{ format('{0}-backup', inputs.target-default-branch) }}
    #    fi
    #  fi
    #
    #  # Create all branches locally
    #  declare -a tracked_branches
    #  for remote in $(git branch -r | grep -v '\->' | grep '^\s*bitbucket/' | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g"); do
    #    branch_name="${remote#bitbucket/}"
    #    if [[ "${branch_name}" == "${{ inputs.source-default-branch }}" || "${branch_name}" == "${{ inputs.target-default-branch }}" ]]; then
    #    printf "\e[0;33m%s\e[0m\n" "Skipping track of branch ${branch_name}"
    #    continue
    #    fi
    #    printf "\e[0;33m%s\e[0m\n" "Attempting to track branch ${branch_name}"
    #    git branch --track "${branch_name}" "${remote}"
    #    if (( $? == 0
    #        tracked_branches+=( "${branch_name}" )
    #      fi
    #    done
    #    readonly tracked_branches
  #
    #    printf "\e[0;33m%s\e[0m\n" "Tracked branches: ${tracked_branches[*]}"
  #
    #    printf "\e[0;33m%s\e[0m\n" "Removing bitbucket remote..."
    #    git remote remove bitbucket
  #
    #    # First, push the default branch to GitHub
    #    printf "\e[0;33m%s\e[0m\n" "Pushing default branch ${{ inputs.target-default-branch }} to github remote"
    #    push_output=$(git push --force origin ${{ inputs.target-default-branch }} 2>&1)
  #
    #    # If failed, exit with error
    #    if (( $? != 0 )); then
    #      echo "::error title=Erro ao migrar branch ${{ inputs.target-default-branch }}::${push_output}"
    #      exit 1
    #    fi
  #
    #    # Then, push all tracked branches, ignoring errors
    #    printf "\e[0;33m%s\e[0m\n" "Proceeding to push all tracked branches..."
    #    declare -a failed_branches
    #    for branch_name in "${tracked_branches[@]}"; do
    #      printf "\e[0;33m%s\e[0m\n" "Pushing tracked branch ${branch_name}"
    #      if ! git push origin "${branch_name}"; then
    #        failed_branches+=( "${branch_name}" )
    #      fi
    #    done
    #    readonly failed_branches
  #
    #    # Log failed branches as warnings.
    #    if (( ${#failed_branches[@]} != 0 )); then
    #      echo "::warning title=Branches não migradas::${failed_branches[*]}"
    #    fi
  #
    #    # Do the same with tags
    #    printf "\e[0;33m%s\e[0m\n" "Proceeding to push all tags..."
    #    declare -a failed_tags
    #    while read -r tag; do
    #      if ! git push origin "$tag"; then
    #        failed_tags+=( "${tag}" )
    #      fi
    #    done < <(git tag -l)
  #
    #    # Log failed tags as warnings.
    #    if (( ${#failed_tags[@]} != 0 )); then
    #      echo "::warning title=Tags não migradas::${failed_tags[*]}"
    #    fi
  #
    #    echo "::endgroup::"
    #       
  #
    ##NOME_ENCONTRADO=$(echo "$REPO_NAME" | tr '-' '\n' | grep -E '^[a-zA-Z0-9]{4}$' || echo "$REPO_NAME" | grep -o 'EINT[^/]*')
    ##      NAME_PROPERTIES=$([ "$NOME_ENCONTRADO" == EINT ] && echo "EINT-${REPO_NAME_PROPERTIES}.properties" || echo "${NOME_ENCONTRADO}.properties")
  # #     
  # #     if [[ -n "$NOME_ENCONTRADO" ]]; then
  # #       DIST_PROPERTIES=($(find . -name "*.properties" -exec grep -h '^dist' {} +))
  # #       echo "Todas as propriedades dist foram armazenadas no array:"
  # #       printf "%s\n" "${DIST_PROPERTIES[@]}"
  # #       for property in "${DIST_PROPERTIES[@]}"; do
  # #          caminho=$(echo "$property" | sed 's/.*="\([^"]*\)".*/\1/')
  # #          echo "$caminho"
  # #          # Set new values in the properties file
  # #          sed -i 's/^dist.*/dist.newvalue=NEW_VALUE/' "$NAME_PROPERTIES"
  # #       done
  # #     else
  # #       echo "Nenhum nome de centro de custo encontrado."
  # #     fi
    #    
##
    ##    if [[ -n "$NOME_ENCONTRADO" ]]; then
    ##      LOWERCASE_NAME=$(echo "$NOME_ENCONTRADO" | tr '[:upper:]' '[:lower:]')
    ##      echo "Buscando arquivo properties no repositório com prefixo: $LOWERCASE_NAME"
    ##      for FILE in $(find . -name "${LOWERCASE_NAME}-*.properties"); do
    ##        echo "Arquivo encontrado: $FILE"
    ##
    ##         while IFS='=' read -r key value; do
    ##         if [[ $key == dist* ]]; then
    ##            echo "Exporting property: ${key}=${value}"
    ##           echo "${key}=${value}" >> $GITHUB_ENV
    ##         fi
    ##       done < "$FILE"
    ##      done
    ##  
    ##      echo "All dist properties have been exported."
    ##    else
    ##     echo "Nenhum nome de centro de custo encontrado."
    #    fi
#
    #
#

    # 3. Leitura do arquivo dist.properties e criação de array
    #- name: Ler dist.properties e criar array de destinos
    #  id: ler_properties
    #  run: |
    #    # Inicializar array de destinos
    #    DESTINOS=()
    #
    #    # Ler todos os valores que começam com 'jar.dist'
    #    while IFS='=' read -r key value; do
    #      if [[ $key == jar.dist* ]]; then
    #        DESTINOS+=("$value")
    #      fi
    #    done < dist.properties
    #
    #    # Exibir o array de destinos
    #    echo "Destinos: ${DESTINOS[@]}"
    #
    #    # 4. Upload do artefato JAR para múltiplos destinos no Nexus

    #- name: Upload do artefato JAR no Nexus
    #  run: |
    #    # Convertendo a string de volta para um array
    #    IFS=' ' read -r -a DESTINOS <<< "${{ env.DESTINOS }}"
    #    
    #    # Iterando sobre cada destino e fazendo o upload
    #    for DESTINO in "${DESTINOS[@]}"; do
    #      echo "Fazendo upload para: $DESTINO"
    #      
    #      # Upload do artefato para o Nexus
    #      curl -u ${{ secrets.NEXUS_USERNAME }}:${{ secrets.NEXUS_PASSWORD }} \
    #        --upload-file target/$JAR_NAME \
    #        $NEXUS_URL/$DESTINO/$JAR_NAME
    #    done

    # 5. Verificação da publicação no Nexus
    #- name: Ler dist.properties e fazer upload do artefato JAR no Nexus
    #  run: |
    #    # Inicializar array de destinos
    #    DESTINOS=()
    #
    #    # Ler todos os valores que começam com 'jar.dist'
    #    while IFS='=' read -r key value; do
    #      if [[ $key == dist* ]]; then
    #        DESTINOS+=("$value")
    #      fi
    #    done < dist.properties
    #
    #    # Exibir o array de destinos
    #    echo "Destinos: ${DESTINOS[@]}"
    #
    #    # Fazer upload do artefato JAR para múltiplos destinos no Nexus
    #    for DESTINO in "${DESTINOS[@]}"; do
    #      echo "Fazendo upload para: $DESTINO"
    #      







#teste

        # # Upload do artefato para o Nexus
        #curl -u ${{ secrets.NEXUS_USERNAME }}:${{ secrets.NEXUS_PASSWORD }} \
        #   --upload-file target/$JAR_NAME \
        #    $NEXUS_URL/$DESTINO/$JAR_NAME
        #done

        